# 알고리즘

### Bubble sort (버블 정렬)

시간복잡도는 $O(n^2)$ 이라서 성능이 구림. 

i인덱스와 i+1인덱스의 값을 비교해서 작은값을 앞으로 큰값을 뒤로 둔다.
정렬한뒤에 숫자들이 정렬되어있지 않으면 다시 반복해서 정렬한다.
```
[**5**,**1**,4,2,6]
[1,**5**,**4**,2,6]
[1,4,**5**,**2**,6]
[1,4,2,**5**,**6**]
[1,4,2,5,6]
1차 순회한 결과. 

[1,**4**,**2**,5,6]
[1,2,**4**,**5**,6]
[1,2,4,**5**,**6**]

2차 순회한 결과
이미 결과값이 정렬되었지만 알고리즘 상으로는 계속해서 반복한다.
```
### Merge Sort (합병 정렬)

시간복잡도는 $O(NlogN)$

단. 30개 이하의 숫자를 정렬할시에는 selectionSort와 차이가없다.

정렬시에 추가적인 메모리가 필요하다 (여분의 배열이 필요하기 때문에)

분할 정복 알고리즘에 속한다. 문제를 풀수없을때 작은 문제로 나누어서 푸는것을 말한다.

배열을 두개로 나누고 나눈것을 두개로 다시 나눈다. 배열의 길이가 1개가 될때까지 계속해서 반으로 나눈다.

최종적으로 나눠진 배열의 길이가 1이 될때까지 나눴다면 나눠진 배열의 내용을 비교해서 정렬한다.

배열의 크기가 큰 경우에 나누고 나눠서 합치는 방식으로 재귀와 분할 정복이 사용된다.

### Selection Sort (선택 정렬)

간단하고 작은수에서는 효과적.(30이하 이상에서는 다른것 쓰는게 좋음)

시간복잡도는 $O(n^2)$

배열을 처음부터 끝까지 살피며 작은수를 제일 앞에다 가져다 둔다.

한번 배열을 돌았을때 하나의 숫자만 정렬 할 수 있다.

```
[5,1,4,7,2,6,8,3] 배열을 처음부터 훑어 가장 작은 1을 앞으로
[1,5,4,7,2,6,8,3] 다시 훑어 2를 앞으로 
[1,2,4,7,5,6,8,3] 3을 앞으로
[1,2,3,7,5,6,8,4]
[1,2,3,4,5,6,8,7]
[1,2,3,4,5,6,8,7]
[1,2,3,4,5,6,7,8] 정렬 끝
```

성능은 구리지만 추가적인 메모리가 필요하지 않다는것이 장점.
